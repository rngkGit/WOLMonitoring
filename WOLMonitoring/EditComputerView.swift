//
//  EditComputerView.swift
//  WOLMonitoring
//
//  Created by Keith Beavers on 9/25/25.
//

// Generated by Google Gemini 2.5 Pro/Flash on Thu Sep 25th, 2025 @ 1003

import SwiftUI

struct EditComputerView: View {
    @Binding var computer: Computer
    @Environment(\.dismiss) var dismiss

    @State private var computerName: String
    
    private var isFormValid: Bool {
        // Form is valid if computerName is not empty and all components are valid.
        return !computerName.trimmingCharacters(in: .whitespaces).isEmpty && areAllComponentsValid()
    }
    
    private func areAllComponentsValid() -> Bool {
        for component in computer.components {
            switch component {
            case .macAddress(let macData):
                if !macData.isValid { return false }
            case .ipAddress(let ipData):
                if !ipData.isValid { return false }
            case .sensor:
                // No validation needed for sensor data currently.
                continue
            }
        }
        return true
    }
    
    // A computed property to check if a MAC address component exists
    private var hasMACAddressComponent: Bool {
        computer.components.contains { component in
            if case .macAddress = component { return true }
            return false
        }
    }

    init(computer: Binding<Computer>) {
        _computer = computer
        _computerName = State(initialValue: computer.wrappedValue.name ?? "")
    }

    var body: some View {
        NavigationStack {
            Form {
                Section("Computer Details") {
                    TextField("Computer Name", text: $computerName)
                }
                
                Section("Details") {
                    ForEach($computer.components) { $component in
                        // Pass the formatMACAddress function to ComponentEditView
                        ComponentEditView(component: $component, formatMACAddress: formatMACAddress)
                    }
                    .onDelete(perform: deleteComponent)
                    .onMove(perform: moveComponent)
                }
            }
            .navigationTitle("Edit Computer")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .cancellationAction) {
                    Button("Cancel", role: .cancel) {
                        dismiss()
                    }
                }
                ToolbarItem(placement: .topBarTrailing) {
                    EditButton()
                }
                // Removed the "plus" button and menu for adding components
                ToolbarItem(placement: .confirmationAction) {
                    Button("Save") {
                        if isFormValid {
                            computer.name = computerName
                            
                            // If a CPU Temp sensor exists but no IP, add a default one.
                            let hasCPUTempSensor = computer.components.contains {
                                if case .sensor(let sData) = $0, sData.type == "CPU Temp" { return true } else { return false }
                            }
                            let hasIPAddress = computer.components.contains {
                                if case .ipAddress = $0 { return true } else { return false }
                            }
                            if hasCPUTempSensor && !hasIPAddress {
                                computer.components.append(.ipAddress(IPData()))
                            }
                            
                            dismiss()
                        }
                    }
                    .disabled(!isFormValid) // Disable Save button if form is not valid
                }
            }
        }
    }
    
    private func deleteComponent(at offsets: IndexSet) {
        computer.components.remove(atOffsets: offsets)
    }
    
    private func moveComponent(from source: IndexSet, to destination: Int) {
        computer.components.move(fromOffsets: source, toOffset: destination)
    }

    /// Formats a MAC address string (with or without separators) into the XX:XX:XX:XX:XX:XX format.
    /// Returns the original string if it cannot be formatted.
    private func formatMACAddress(_ mac: String) -> String {
        let cleanMAC = mac.replacingOccurrences(of: "[: -]", with: "", options: .regularExpression)
        
        guard cleanMAC.count == 12 else {
            return mac // Return original if not 12 hex chars after cleaning
        }
        
        var formatted = ""
        for i in 0..<6 {
            let startIndex = cleanMAC.index(cleanMAC.startIndex, offsetBy: i * 2)
            let endIndex = cleanMAC.index(startIndex, offsetBy: 2)
            formatted += cleanMAC[startIndex..<endIndex]
            if i < 5 {
                formatted += ":"
            }
        }
        return formatted
    }
}

fileprivate struct ComponentEditView: View {
    @Binding var component: Component
    var formatMACAddress: (String) -> String // Closure to inject the formatting function
    
    @State private var macAddressError: String?
    @State private var ipAddressError: String?
    
    var body: some View {
        // Switch on the wrappedValue of the binding, then use the new sub-bindings.
        switch component {
        case .ipAddress:
            if let ipDataBinding = $component.ipAddress {
                VStack(alignment: .leading) {
                    Text("IP Address")
                        .font(.caption)
                        .foregroundStyle(.secondary)
                    TextField("Address", text: ipDataBinding.address)
                        .autocorrectionDisabled()
                        .textInputAutocapitalization(.never)
                        .keyboardType(.decimalPad)
                        .onChange(of: ipDataBinding.wrappedValue.address) {
                            validateIPAddressInput(ipDataBinding.wrappedValue.address)
                        }
                    
                    if let error = ipAddressError {
                        Text(error)
                            .font(.caption)
                            .foregroundStyle(.red)
                    }
                }
                .onAppear {
                    // Perform initial validation.
                    validateIPAddressInput(ipDataBinding.wrappedValue.address)
                }
            }
            
        case .macAddress:
            if let macDataBinding = $component.macAddress {
                
                // Custom binding to format MAC address on input change
                let formattedMacAddressBinding = Binding<String>(
                    get: { macDataBinding.wrappedValue.address },
                    set: { newValue in
                        // Apply formatting before setting the value
                        macDataBinding.wrappedValue.address = formatMACAddress(newValue)
                        // Trigger validation after formatting
                        validateMacAddressInput(macDataBinding.wrappedValue.address)
                    }
                )

                VStack(alignment: .leading) {
                    Text("MAC Address")
                        .font(.caption)
                        .foregroundStyle(.secondary)
                    TextField("Address", text: formattedMacAddressBinding) // Use the custom binding
                        .autocorrectionDisabled()
                        .textInputAutocapitalization(.never)
                        .onChange(of: formattedMacAddressBinding.wrappedValue) {
                            // Validation is now handled in the custom binding's setter
                        }
                    
                    if let error = macAddressError {
                        Text(error)
                            .font(.caption)
                            .foregroundStyle(.red)
                    }
                }
                .onAppear {
                    // Perform initial validation on the existing value
                    validateMacAddressInput(macDataBinding.wrappedValue.address)
                }
            }
            
        case .sensor:
            if let sensorDataBinding = $component.sensor {
                
                // Proxy binding for value to handle C/F conversion for display/input
                // This binding is no longer used for a TextField, but if a Text is needed
                // to display the value (non-editable), this can still be useful.
                let _ = Binding<Double>(
                    get: {
                        if sensorDataBinding.wrappedValue.unit == "ºF" {
                            return SensorData.celsiusToFahrenheit(sensorDataBinding.wrappedValue.value)
                        } else {
                            return sensorDataBinding.wrappedValue.value
                        }
                    },
                    set: { newValue in
                        if var currentSensorData = sensorDataBinding.wrappedValue as? SensorData {
                            if currentSensorData.unit == "ºF" {
                                currentSensorData.value = SensorData.fahrenheitToCelsius(newValue)
                            } else {
                                currentSensorData.value = newValue
                            }
                            sensorDataBinding.wrappedValue = currentSensorData // Update the binding
                        }
                    }
                )
                
                VStack(alignment: .leading) {
                    Text("Sensor")
                        .font(.caption)
                        .foregroundStyle(.secondary)

                    // LabeledContent for Sensor Name, with TextAlignment to trailing
                    LabeledContent {
                        TextField("Name", text: sensorDataBinding.name)
                            .multilineTextAlignment(.trailing) // Ensures text is on the right
                    } label: {
                        Text("Sensor Name")
                    }
                    
                    // Picker for Sensor Type
                    Picker("Sensor Type", selection: sensorDataBinding.type) {
                        Text("CPU Temp").tag("CPU Temp")
                        // Add other sensor types here if needed
                    }
                    .onChange(of: sensorDataBinding.type.wrappedValue) { oldValue, newValue in
                        // Name is now editable, so only suggest type if name is empty or matches old type
                        if sensorDataBinding.name.wrappedValue.isEmpty || sensorDataBinding.name.wrappedValue == oldValue {
                            sensorDataBinding.name.wrappedValue = newValue
                        }
                    }
                    
                    // Removed LabeledContent for "Value" as requested
                        
                    // LabeledContent for Unit
                    LabeledContent {
                        if sensorDataBinding.wrappedValue.type == "CPU Temp" {
                            Picker("", selection: sensorDataBinding.unit) { // Empty label as LabeledContent provides it
                                Text("Celsius (ºC)").tag("ºC")
                                Text("Fahrenheit (ºF)").tag("ºF")
                            }
                            .pickerStyle(.menu)
                        } else {
                            TextField("", text: sensorDataBinding.unit) // Empty label
                                .autocorrectionDisabled()
                                .textInputAutocapitalization(.never)
                                .frame(width: 50) // Keep frame for custom unit field
                        }
                    } label: {
                        Text("Unit")
                    }
                }
            }
        }
    }
    
    /// Validates the given MAC address input and updates the `macAddressError` state.
    private func validateMacAddressInput(_ input: String) {
        let trimmedInput = input.trimmingCharacters(in: .whitespaces)
        
        if trimmedInput.isEmpty {
            macAddressError = "MAC Address cannot be empty."
        } else if !MACAddressData.isValidMACAddress(trimmedInput) {
            macAddressError = "Invalid MAC Address format. E.g., 00:11:22:33:44:55"
        } else {
            macAddressError = nil // MAC address is valid
        }
    }
    
    /// Validates the given IP address input and updates the `ipAddressError` state.
    private func validateIPAddressInput(_ input: String) {
        let trimmedInput = input.trimmingCharacters(in: .whitespaces)
        
        if trimmedInput.isEmpty {
            ipAddressError = "IP Address cannot be empty."
        } else if !IPData.isValidIPAddress(trimmedInput) {
            ipAddressError = "Invalid IP Address format. E.g., 192.168.1.1"
        } else {
            ipAddressError = nil // IP address is valid
        }
    }
}
