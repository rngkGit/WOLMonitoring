//
//  Component.swift
//  WOLMonitoring
//
//  Created by Keith Beavers on 9/25/25.
//

// Generated by Google Gemini 2.5 Pro on Thu Sep 25th, 2025 @ 0949

import Foundation
import SwiftUI

// A struct to hold data for a sensor.
struct SensorData: Codable, Hashable, Identifiable {
    let id: UUID
    var name: String
    var type: String // New: Added type property
    var value: Double
    var unit: String
    
    // Updated initializer to support the new type property
    init(id: UUID = UUID(), name: String = "New Sensor", type: String = "CPU Temp", value: Double = 0.0, unit: String? = nil) {
        self.id = id
        self.name = name
        self.type = type
        self.value = value
        
        // Default unit based on type, if not explicitly provided
        if let explicitUnit = unit {
            self.unit = explicitUnit
        } else if type == "CPU Temp" {
            self.unit = "ÂºC"
        } else {
            self.unit = "" // Default for other types if any, or you can make it required later
        }
    }
}

// A struct to hold data for an IP address.
struct IPData: Codable, Hashable, Identifiable {
    let id: UUID
    var address: String
    
    init(id: UUID = UUID(), address: String = "192.168.0.1") {
        self.id = id
        self.address = address
    }
}

// An enum to represent different types of components a computer can have.
enum Component: Codable, Hashable, Identifiable {
    case ipAddress(IPData)
    case sensor(SensorData)
    
    var id: UUID {
        switch self {
        case .ipAddress(let data):
            return data.id
        case .sensor(let data):
            return data.id
        }
    }
    
    var name: String {
        switch self {
        case .ipAddress:
            return "IP Address"
        case .sensor(let data):
            return data.name
        }
    }
}

// MARK: - Binding Extensions
extension Binding where Value == Component {
    var ipAddress: Binding<IPData>? {
        guard case .ipAddress = wrappedValue else { return nil }
        return Binding<IPData>(
            get: {
                if case .ipAddress(let data) = self.wrappedValue {
                    return data
                }
                fatalError("Attempted to access ipAddress when component is not an IP address.")
            },
            set: { newValue in
                self.wrappedValue = .ipAddress(newValue)
            }
        )
    }
    
    var sensor: Binding<SensorData>? {
        guard case .sensor = wrappedValue else { return nil }
        return Binding<SensorData>(
            get: {
                if case .sensor(let data) = self.wrappedValue {
                    return data
                }
                fatalError("Attempted to access sensor when component is not a sensor.")
            },
            set: { newValue in
                self.wrappedValue = .sensor(newValue)
            }
        )
    }
}
