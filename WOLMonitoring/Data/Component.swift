//
//  Component.swift
//  WOLMonitoring
//
//  Created by Keith Beavers on 9/25/25.
//

// Generated by Google Gemini 2.5 Pro on Thu Sep 25th, 2025 @ 0949

import Foundation
import SwiftUI

struct IPData: Identifiable, Codable, Hashable {
    var id = UUID()
    var address: String = ""
    
    var isValid: Bool {
        IPData.isValidIPAddress(address)
    }
    
    static func isValidIPAddress(_ ip: String) -> Bool {
        let trimmedIP = ip.trimmingCharacters(in: .whitespaces)
        if trimmedIP.isEmpty { return false } // Empty is not considered valid for saving.
        
        // An IP address must have 4 parts separated by dots.
        let parts = trimmedIP.split(separator: ".")
        guard parts.count == 4 else { return false }
        
        // Each part must be a number between 0 and 255.
        for part in parts {
            if let number = Int(part), number >= 0 && number <= 255 {
                continue
            } else {
                return false
            }
        }
        
        return true
    }
}

struct MACAddressData: Identifiable, Codable, Hashable {
    var id = UUID()
    var address: String = ""
    
    var isValid: Bool {
        MACAddressData.isValidMACAddress(address)
    }
    
    static func isValidMACAddress(_ mac: String) -> Bool {
        let trimmedMac = mac.trimmingCharacters(in: .whitespaces)
        if trimmedMac.isEmpty { return false } // Empty is not considered valid for saving.
        
        // Remove common separators (colon, hyphen, space) for validation
        let cleanMAC = trimmedMac.replacingOccurrences(of: "[: -]", with: "", options: .regularExpression)
        
        // A valid MAC address must consist of exactly 12 hexadecimal characters
        guard cleanMAC.count == 12 else {
            return false
        }
        
        // Check if all characters in the cleaned string are hexadecimal digits
        let hexCharset = CharacterSet(charactersIn: "0123456789abcdefABCDEF")
        return cleanMAC.rangeOfCharacter(from: hexCharset.inverted) == nil
    }
}

struct SensorData: Identifiable, Codable, Hashable {
    var id = UUID()
    var name: String = "CPU Temp"
    var type: String = "CPU Temp"
    var value: Double = 0.0 // Stored internally as Celsius
    var unit: String = "ºC" // Preferred display unit

    // Helper static functions for conversion
    static func celsiusToFahrenheit(_ celsius: Double) -> Double {
        return (celsius * 9 / 5) + 32
    }

    static func fahrenheitToCelsius(_ fahrenheit: Double) -> Double {
        return (fahrenheit - 32) * 5 / 9
    }
    
    // NEW: Computed property for the display string, handles conversion
    var displayString: String {
        let displayValue: Double
        if unit == "ºF" {
            displayValue = SensorData.celsiusToFahrenheit(value)
        } else {
            displayValue = value
        }
        return "\(String(format: "%.1f", displayValue)) \(unit)"
    }
}

enum Component: Identifiable, Codable, Hashable {
    case ipAddress(IPData)
    case sensor(SensorData)
    case macAddress(MACAddressData)

    var id: UUID {
        switch self {
        case .ipAddress(let data): return data.id
        case .sensor(let data): return data.id
        case .macAddress(let data): return data.id
        }
    }
}

extension Binding where Value == Component {
    var ipAddress: Binding<IPData>? {
        if case .ipAddress(let data) = self.wrappedValue {
            return Binding<IPData>(
                get: { data },
                set: { self.wrappedValue = .ipAddress($0) }
            )
        }
        return nil
    }
    
    var sensor: Binding<SensorData>? {
        if case .sensor(let data) = self.wrappedValue {
            return Binding<SensorData>(
                get: { data },
                set: { self.wrappedValue = .sensor($0) }
            )
        }
        return nil
    }
    
    var macAddress: Binding<MACAddressData>? {
        if case .macAddress(let data) = self.wrappedValue {
            return Binding<MACAddressData>(
                get: { data },
                set: { self.wrappedValue = .macAddress($0) }
            )
        }
        return nil
    }
}
