//
//  Component.swift
//  WOLMonitoring
//
//  Created by Keith Beavers on 9/25/25.
//

// Generated by Google Gemini 2.5 Pro on Thu Sep 25th, 2025 @ 0949

import Foundation
import SwiftUI

struct IPData: Identifiable, Codable, Hashable {
    var id = UUID()
    var address: String = ""
}

struct MACAddressData: Identifiable, Codable, Hashable {
    var id = UUID()
    var address: String = ""
    
    var isValid: Bool {
        MACAddressData.isValidMACAddress(address)
    }
    
    static func isValidMACAddress(_ mac: String) -> Bool {
        let trimmedMac = mac.trimmingCharacters(in: .whitespaces)
        if trimmedMac.isEmpty { return false } // Empty is not considered valid for saving.
        
        // Remove common separators (colon, hyphen, space) for validation
        let cleanMAC = trimmedMac.replacingOccurrences(of: "[: -]", with: "", options: .regularExpression)
        
        // A valid MAC address must consist of exactly 12 hexadecimal characters
        guard cleanMAC.count == 12 else {
            return false
        }
        
        // Check if all characters in the cleaned string are hexadecimal digits
        let hexCharset = CharacterSet(charactersIn: "0123456789abcdefABCDEF")
        return cleanMAC.rangeOfCharacter(from: hexCharset.inverted) == nil
    }
}

// Since the definition for SensorData was not provided, this is a minimal
// implementation based on its usage in other views.
struct SensorData: Identifiable, Codable, Hashable {
    var id = UUID()
    var name: String = "CPU Temp"
    var type: String = "CPU Temp"
    var value: Double = 0.0
    var unit: String = "ÂºC"
}

enum Component: Identifiable, Codable, Hashable {
    case ipAddress(IPData)
    case sensor(SensorData)
    case macAddress(MACAddressData)

    var id: UUID {
        switch self {
        case .ipAddress(let data): return data.id
        case .sensor(let data): return data.id
        case .macAddress(let data): return data.id
        }
    }
}

extension Binding where Value == Component {
    var ipAddress: Binding<IPData>? {
        if case .ipAddress(let data) = self.wrappedValue {
            return Binding<IPData>(
                get: { data },
                set: { self.wrappedValue = .ipAddress($0) }
            )
        }
        return nil
    }
    
    var sensor: Binding<SensorData>? {
        if case .sensor(let data) = self.wrappedValue {
            return Binding<SensorData>(
                get: { data },
                set: { self.wrappedValue = .sensor($0) }
            )
        }
        return nil
    }
    
    var macAddress: Binding<MACAddressData>? {
        if case .macAddress(let data) = self.wrappedValue {
            return Binding<MACAddressData>(
                get: { data },
                set: { self.wrappedValue = .macAddress($0) }
            )
        }
        return nil
    }
}
